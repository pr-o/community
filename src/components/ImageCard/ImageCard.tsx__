// import React, { FC, useState, useEffect, useRef, forwardRef, createRef, MutableRefObject } from 'react';
// import Image from 'next/image'
// import * as THREE from 'three';
// import { gsap, Power2 } from 'gsap';
// import styled from '@emotion/styled';;
// import vertexShader from 'lib/glsl/vertexShader.glsl';
// import fragmentShader from 'lib/glsl/fragmentShader.glsl';

// const blankSVG = `data:image/svg+xml;charset=utf8,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E`
// const img = '/images/a-thousand-paths-dark.jpg';
// const hoverImg = '/images/clint-mckoy.jpg'
// import { Scene } from 'scenes/scene'
// interface ComponentProps {
// 	image?: string;
// 	title?: string;
// 	subTitle?: string;
// 	descriptions?: Array<string>;
// 	callBack?: any;
// 	addToScene?: any;
// 	scene?: any;
// 	imageSrc?: any;
// 	hoverImageSrc?: any;
// }


// let uniforms: any = {
// 	u_time: { value: 0 },
// 	u_progressHover: { value: 0 },
// };


// // const updateTime = () => {
// // 	uniforms.u_time.value += 0.01
// // }

// const ImageCard: FC<ComponentProps> = ({ addToScene, imageSrc, hoverImageSrc, title, subTitle, descriptions, callBack }) => {

// 	// const scene = new THREE.Scene()





// 	const loader = new THREE.TextureLoader()
// 	const sizes = new THREE.Vector2(0, 0);
// 	const offset = new THREE.Vector2(0, 0);
// 	const mouse = new THREE.Vector2(0, 0);
// 	// const time = useRef(0)

// 	// const imageRef: MutableRefObject<HTMLElement | undefined> = useRef()
// 	const imageRef: React.RefObject<HTMLImageElement> = createRef()
// 	let imageSrcRef: MutableRefObject<any> = useRef()
// 	let hoverImageSrcRef: MutableRefObject<any> = useRef()
// 	const [imageLoaded, setImageLoaded] = useState(false)
// 	const [hoverImageLoaded, setHoverImageLoaded] = useState(false)


// 	const img = '/images/a-thousand-paths-dark.jpg';
// 	const hoverImg = '/images/clint-mckoy.jpg'

// 	const [uniforms2, setUniforms2] = useState({
// 		u_time: { value: 1 },
// 		u_progressHover: { value: 0 },
// 		u_mouse: { value: mouse },
// 		u_image: { type: 't', value: imageSrcRef.current },
// 		u_imagehover: { type: 't', value: hoverImageSrcRef.current },
// 		// u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
// 		u_res: { value: new THREE.Vector2(1000, 1000) },
// 	})
// 	const canvasRef = React.useRef(null);

// 	useEffect(() => {
// 		// imageSrcRef.current = loader.load((imageRef.current as HTMLElement)?.dataset.src as string, () => setImageLoaded(true))
// 		// hoverImageSrcRef.current = loader.load((imageRef.current as HTMLElement)?.dataset.hover as string, () => setHoverImageLoaded(true));
// 		imageSrcRef.current = loader.load(img, () => setImageLoaded(true))
// 		hoverImageSrcRef.current = loader.load(hoverImg, () => setHoverImageLoaded(true));

// 		const sceneC = new Scene()

// 		const scene = sceneC.getScene()

// 		console.log('wat', scene)

// 		const geometry = new THREE.PlaneBufferGeometry(10, 10, 10, 10);
// 		// const material = new THREE.ShaderMaterial({
// 		// 	uniforms: uniforms2,
// 		// 	vertexShader: vertexShader,
// 		// 	fragmentShader: fragmentShader,
// 		// 	defines: {
// 		// 		PR: window.devicePixelRatio.toFixed(1),
// 		// 	},
// 		// });
// 		const material = new THREE.MeshBasicMaterial({ color: 0xff008080, wireframe: true })

// 		const mesh = new THREE.Mesh(geometry, material);

// 		mesh.position.set(offset.x, offset.y, 0);
// 		mesh.scale.set(sizes.x, sizes.y, 1);

// 		scene.add(mesh)

// 		const clock = new THREE.Clock();

// 		const renderer = new THREE.WebGLRenderer();
// 		renderer.setSize(window.innerWidth, window.innerHeight);
// 		// renderer.setSize(1000, 800);

// 		document.body.appendChild(renderer.domElement);
// 		// canvasRef.current?.appendChild(renderer.domElement);

// 		const perspective = 800;

// 		const fov = (180 * (2 * Math.atan(window.innerHeight / 2 / perspective))) / Math.PI;

// 		const camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 1000);
// 		camera.position.set(0, 0, perspective);

// 		const update = () => {
// 			const time = clock.getElapsedTime();

// 			// console.log('time =>', time)

// 			window.requestAnimationFrame(update);
// 			// this.figure.update();
// 			renderer.render(scene, camera);
// 		}

// 		update()
// 		console.log('wat', scene)

// 	}, []);



// 	const after = () => {
// 		// uniforms = {
// 		// 	...uniforms,
// 		// 	u_time: { value: 0 },
// 		// 	u_mouse: { value: mouse },
// 		// 	u_image: { type: 't', value: imageSrcRef.current },
// 		// 	u_imagehover: { type: 't', value: hoverImageSrcRef.current },
// 		// 	u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
// 		// }

// 		const { width, height, top, left }: DOMRect = (imageRef.current as HTMLElement).getBoundingClientRect();

// 		sizes.set(width, height);

// 		offset.set(
// 			left - window.innerWidth / 2 + width / 2,
// 			-top + window.innerHeight / 2 - height / 2
// 		);

// 		// createMesh()



// 		// addToScene(scene, mesh)
// 		// callBack()

// 	}


// 	// const createMesh = () => {

// 	// 	const geometry = new THREE.PlaneBufferGeometry(1, 1, 1, 1);
// 	// 	const material = new THREE.ShaderMaterial({
// 	// 		uniforms: uniforms,
// 	// 		vertexShader: vertexShader,
// 	// 		fragmentShader: fragmentShader,
// 	// 		defines: {
// 	// 			PR: window.devicePixelRatio.toFixed(1),
// 	// 		},
// 	// 	});

// 	// 	const mesh = new THREE.Mesh(geometry, material);

// 	// 	mesh.position.set(offset.x, offset.y, 0);
// 	// 	mesh.scale.set(sizes.x, sizes.y, 1);

// 	// 	scene.add(mesh);
// 	// }

// 	return (

// 		<div ref={canvasRef} style={{ border: '4px solid yellow' }} />

// 		// <ArticleTile>
// 		// 	<FigureTile>
// 		// 		<img id={`image-tile`}
// 		// 			ref={imageRef}
// 		// 			src={blankSVG} data-src={img} data-hover={hoverImg} width={800} height={600} alt="image" />
// 		// 		{/* <ImageTile id={`image-tile`}
// 		// 			src={blankSVG} data-src={img} data-hover={hoverImg} width={800} height={600} alt="image" /> */}
// 		// 	</FigureTile>
// 		// </ArticleTile>
// 	);
// }

// export default ImageCard;


// const ArticleTile = styled.section`
// 	width: 50vw;
// 	flex: 0 0 auto;
// `

// const FigureTile = styled.figure`
//   margin: 0;
// 	padding: 0;
// 	width: 100%;
// `

// // interface ImageProps {
// // 	id?: any;
// // 	// ref: MutableRefObject<HTMLImageElement>;
// // 	ref: any;
// // 	"data-src": any;
// // 	"data-hover": any;
// // 	dataset: any;
// // }

// // const NEWImage = styled(img) <ImageProps>`
// // 	object-fit: cover;
// // 	object-position: center;
// // `
